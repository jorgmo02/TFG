Clase autovarctl.h pinta bien
MainWindow parece el gestor de todo
UI_MainWindow

mainwindow.cpp ~linea 266 hay que insertar una tab en el QTreeWidget

UI_MainWindow.h ~linea 176 hay que hacer lo mismo q con el actionViewStack
UI_MainWindow.h ~linea 573 addAction al menuView
UI_MainWindow.h ~linea 645 setText

^
|

esto es mentira!! este stack es el de la pestaña de abajo a la derecha, no el lateral al a derecha.


Clase MainWindow contiene una instancia de UI_MainWindow


AutoVarCtl es una clase que parece agrupar toda la funcionalidad de una pestañita
/**
* @brief Displays local variables (on the stack).
  Hereda de VarCtl
*/

autovarctl.cpp ~linea 57 ahí se pone el algo


// ----------------------------------------------------------------------------------

ui_mainwindow.h ~linea 116 mirar el varWidget (ui_mainwindow.cpp linea 488)
VICTORIA ES EL PARECIDO AL VARWIDGET (en realidad al autoWidget)

ahora toca modificarlo i guess

// ----------------------------------------------------------------------------------

mainwindow.h m_autoVarCtl es quien se encarga de presentar los valores de las variables
	(mirar mainwindow.cpp linea 783)
	
// ----------------------------------------------------------------------------------


Core (core.cpp) es la clase que se encarga de comunicar gdb e interfaz, mediante llamadas como (core.cpp line 1471 gdbGetThreadList):

		GdbCom& com = GdbCom::getInstance();
	    	Tree resultData;

	    	if(m_targetState == ICore::TARGET_STARTING || m_targetState == ICore::TARGET_RUNNING)
	    	{
			if(m_inf)
		    		m_inf->ICore_onMessage("Program is currently running");
			return;
		}

->>>>>>>	com.commandF(&resultData, "-thread-info");


tengo que hacer un gdbGetMemoryMap(), básicamente, en la clase Core y enlazarlo con la función correspondiente que actualice la UI

// ----------------------------------------------------------------------------------


