Clase autovarctl.h pinta bien
MainWindow parece el gestor de todo
UI_MainWindow

mainwindow.cpp ~linea 266 hay que insertar una tab en el QTreeWidget

UI_MainWindow.h ~linea 176 hay que hacer lo mismo q con el actionViewStack
UI_MainWindow.h ~linea 573 addAction al menuView
UI_MainWindow.h ~linea 645 setText

^
|

esto es mentira!! este stack es el de la pestaña de abajo a la derecha, no el lateral al a derecha.


Clase MainWindow contiene una instancia de UI_MainWindow


AutoVarCtl es una clase que parece agrupar toda la funcionalidad de una pestañita
/**
* @brief Displays local variables (on the stack).
  Hereda de VarCtl
*/

autovarctl.cpp ~linea 57 ahí se pone el algo


// ----------------------------------------------------------------------------------
HECHO
ui_mainwindow.h ~linea 116 mirar el varWidget (ui_mainwindow.cpp linea 488)
VICTORIA ES EL PARECIDO AL VARWIDGET (en realidad al autoWidget)
HECHO
// ----------------------------------------------------------------------------------
HECHO
mainwindow.h m_autoVarCtl es quien se encarga de presentar los valores de las variables
	(mirar mainwindow.cpp linea 783)
HECHO
// ----------------------------------------------------------------------------------
HECHO
Mirar para modificar el restore default view (mainwindow.cpp 224)
HECHO
// ----------------------------------------------------------------------------------

core.cpp línea 1358: ICore_onStopped
mirar donde se llama el ICore_onStopper y lo que ocurre cuando se llama
(en realidad, mirar todos los ICore_)

com.cpp -> GdbCom::dispatchResp() ~linea 1177

tree.h parseGroup ~linea 98 (mirar definicion en cpp)

mainwindow HEREDA de ICore así que hay que tocar esas implementaciones para añadir el metodo onMemoryChanged supongo

mirar:
	core.gdbRun(); gd.cpp ~linea 216
	
GdbCom::dispatchResponse, el listener es el mainwindow y parece que GdbCom reenvía la info al mainwindow

// ----------------------------------------------------------------------------------

En la ventana:
	Una línea por región
	2/3  columnas según si queda muy sobrecargado o no
		- posición de memoria inicial
		- fichero de respaldo
		- (¿tamaño?)
	flechita desplegable que muestre más info
		- (¿tamaño?)
		- posición de memoria final
		- permisos del fichero de respaldo
		- nº paginas

// ----------------------------------------------------------------------------------


Core (core.cpp) es la clase que se encarga de comunicar gdb e interfaz, mediante llamadas como (core.cpp line 1471 gdbGetThreadList):

		GdbCom& com = GdbCom::getInstance();
	    	Tree resultData;

	    	if(m_targetState == ICore::TARGET_STARTING || m_targetState == ICore::TARGET_RUNNING)
	    	{2
			if(m_inf)
		    		m_inf->ICore_onMessage("Program is currently running");
			return;
		}

->>>>>>>	com.commandF(&resultData, "-thread-info");


tengo que hacer un gdbGetMemoryMap(), básicamente, en la clase Core y enlazarlo con la función correspondiente que actualice la UI

// ----------------------------------------------------------------------------------

mirar GDB/MI pmap / popen.

// ----------------------------------------------------------------------------------

mirar:
	- cat /proc/(pid)/maps
		- Muestra todas las regiones + librerias
		- Tengo que parsear la salida (mirar strtok)
	- pmap -x (pid)
		- mirar también popen: 
			FILE* popen("pmap -x (pid)", "r")
			- Uso el FILE* para leer la salida estandar de pmap -x (pid)
			pclose(FILE*)
			
	el pid lo tengo en Core::m_pid, creo
// ----------------------------------------------------------------------------------

Mirar posibilidad de resaltar variable (adicional)

// ----------------------------------------------------------------------------------



